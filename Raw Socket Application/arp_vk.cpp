#include <stdio.h>#include<malloc.h>#include<string.h>#include<signal.h>#include<stdbool.h>#include<sys/socket.h>#include<sys/types.h>#include<stdlib.h>#include<linux/if_packet.h>#include<netinet/in.h>		 #include<netinet/if_ether.h> // for ethernet header#include<netinet/ip.h>		// for ip header#include<netinet/udp.h>		// for udp header#include<netinet/tcp.h>#include<arpa/inet.h>    #include<sys/ioctl.h>#include<net/if.h>#include<netinet/if_ether.h>#include<error.h>#include<time.h>#include<bits/stdc++.h>#include<pthread.h>#include<unistd.h>using namespace std;pthread_cond_t cond = PTHREAD_COND_INITIALIZER;pthread_mutex_t locker = PTHREAD_MUTEX_INITIALIZER;char interface[30];char sender_ip_address[30];char receiver_ip_address[30];int timer;unsigned char* buffer = NULL;/* * HW address type           => 2 Bytes * Protocal address type	2 Bytes * HW address length		1 Byte * Protocol adress length	1 Byte * Operation			2 Bytes * Source hardware address	6 Bytes * Sourcs protocol address	4 Bytes * Target hardware address      6 Bytes * Target protocol address	4 Bytes * // struct ethhdr{ 	unsigned char h_dest[ETH_ALEN];	unsigned char h_source[ETH_ALEN];	_be16        h_proto; } __attribute_((packed)); * */void  extract_ethernet_header(void * buffer){	struct ethhdr eth = (struct ethhdr*)buffer;	printf("Source Address : %.2X-%.2X-%.2X-%.2X-%.2X-%.2X\n",(unsigned)eth->h_source[0],(unsigned)eth->h_source[1],(unsigned)eth->h_source[2]);	printf("Destination Address : %.2X-%.2X-%.2X-%.2X-%.2X-%.2X\n",(unsigned)eth->h_dest[0],(unsigned)eth->h_dest[1],(unsigned)eth->h_dest[2]);	printf("Protocol : %d\n",ntohs(eth->h_proto));	return ;}void* timerFun(void* ptr){	sleep(timer);	pthread_cond_signal(&cond);}void* packet_processor(void* ptr){	pthread_mutex_lock(&locker);	pthread_cond_wait(&cond,&locker);	if(buffer == NULL){		printf(" No ARP response received\n TIMED OUT\n");		return NULL;	}	extract_ethernet_header(buffer);	free(buffer);	return NULL;}bool check_packet(unsigned char* packet){	unsigned int arp_protocol = 2054;	struct ethhdr* eth = (struct ethhdr*)packet;                if(ntohs(eth->h_proto) != arp_protocol){                        memset(packet,0,1024);                        return false;                }          	 int pos = sizeof(struct ethhdr)+6;                int operation =0;                int y = packet[pos];                operation = y;                operation = operation<<8;                pos++;                y = packet[pos];                operation = operation | y;                if(operation != 2){			return false;		}                pos = sizeof(struct ethhdr)+14;                string received_ip = "";                int x = packet[pos];                pos++;                received_ip+= to_string(x);                received_ip += ".";                x = packet[pos];                pos++;                received_ip+= to_string(x);                received_ip += ".";                x = packet[pos];                pos++;                received_ip+= to_string(x);                received_ip += ".";                x = packet[pos];                pos++;                received_ip+= to_string(x);                if(received_ip != receiver_ip_address){			return false;		}		return true;}void waitForResponse(void ptr){	int fd = ((int)ptr);	unsigned char packet[1024];	//double waiting_time = 0.05;        memset(packet,1024,0);	unsigned int arp_protocol = 2054;        struct sockaddr sock_address;        socklen_t size = sizeof(sock_address);	//clock_t start = clock();	int flag =1;	while(1){		/*		double duration = (float)(clock() - start)/CLOCKS_PER_SEC;		if(duration > waiting_time){			flag = 0;			break;		}		/			int recv_size = recvfrom(fd,packet,sizeof(packet),0,&sock_address,&size);			if(recv_size < 0 ){				perror("Receive failed");				exit(1);			}			if(check_packet(packet) == false) continue;			buffer = (unsigned char *) malloc(1024);			memcpy(buffer,packet,1024);			break;		}		return NULL;	}void extract_tcp_layer_header(unsigned char buffer){	struct iphdr ip = (struct iphdr *)( buffer + sizeof(struct ethhdr) );	/ getting actual size of IP header*/	unsigned short iphdrlen = ip->ihl*4;	/* getting pointer to udp header*/	struct udphdr udp=(struct udphdr)(buffer + iphdrlen + sizeof(struct ethhdr));	printf("Source Port : %d\n" , ntohs(udp->source));	printf("Destination Port : %d\n" , ntohs(udp->dest));	printf("UDP Length : %d\n" , ntohs(udp->len));	printf("UDP Checksum : %d\n" , ntohs(udp->check));}/* * HW address type           => 2 Bytes * Protocal address type        2 Bytes * HW address length            1 Byte * Protocol adress length       1 Byte * Operation                    2 Bytes * Source hardware address      6 Bytes * Sourcs protocol address      4 Bytes * Target hardware address      6 Bytes * Target protocol address      4 Bytes * /void fillARP (unsigned char * buffer,struct ifreq *ifreq_c){	int pos = sizeof(struct ethhdr);	// hardware type 01 for ethernet		buffer[pos] = 0;	pos++;	buffer[pos] = 1;	pos++;	// Protocol address type for IP is  0X0800	unsigned short opcode = 2048; // Decimal representation of 0X0800	buffer[pos] = (opcode>>8);	pos++;	buffer[pos] = opcode;	pos++;	// Hardware address length	buffer[pos] = 6;	pos++;	// Logical address length	buffer[pos] = 4;	pos++;	// Operation	buffer[pos] = 0;	pos++;	buffer[pos] = 1;	pos++;	// Sender Hardware address	buffer[pos] = (ifreq_c->ifr_hwaddr).sa_data[0];	pos++;	buffer[pos] = (ifreq_c->ifr_hwaddr).sa_data[1];        pos++;	buffer[pos] = (ifreq_c->ifr_hwaddr).sa_data[2];        pos++;	buffer[pos] = (ifreq_c->ifr_hwaddr).sa_data[3];        pos++;	buffer[pos] = (ifreq_c->ifr_hwaddr).sa_data[4];        pos++;	buffer[pos] = (ifreq_c->ifr_hwaddr).sa_data[5];        pos++;	// Sender IP Address	in_addr_t ip = inet_addr(sender_ip_address);	buffer[pos] = ip;	pos++;	buffer[pos] = (ip>>8);	pos++;	buffer[pos] = (ip>>16);        pos++;	buffer[pos] = (ip>>24);        pos++;	// Receiver Hardware Address	buffer[pos] = 0;	pos++;	buffer[pos] = 0;        pos++;	buffer[pos] = 0;        pos++;	buffer[pos] = 0;        pos++;	buffer[pos] = 0;        pos++;	buffer[pos] = 0;        pos++;	// Receiver IP Address		ip = inet_addr(receiver_ip_address);        buffer[pos] = ip;        pos++;        buffer[pos] = (ip>>8);        pos++;        buffer[pos] = (ip>>16);        pos++;        buffer[pos] = (ip>>24);        pos++;	return;}int main(int args, char argv[]){/* Comand line argument handle /	strcpy(interface,argv[1]);	printf("%s\n",interface);	strcpy(sender_ip_address,argv[2]);	strcpy(receiver_ip_address,argv[3]);	timer = atoi(argv[4]);	int fd = socket(AF_PACKET,SOCK_RAW,htons(ETH_P_ALL));	if(fd <0){		perror("Socket Faied to open :");		exit(1);	}	unsigned char packet[64];	memset(packet,64,0);	struct sockaddr sock_address;	socklen_t size = sizeof(sock_address);	/ Index of the Interface /	struct ifreq ifreq_i;	memset(&ifreq_i,0,sizeof(ifreq_i));	strncpy(ifreq_i.ifr_name,interface,IFNAMSIZ-1); //giving name of Interface	if((ioctl(fd,SIOCGIFINDEX,&ifreq_i))<0){		perror("Error in index \n");		exit(1);	}/ Mac Address of the Interface /		struct ifreq ifreq_c;	memset(&ifreq_c,0,sizeof(ifreq_c));	strncpy(ifreq_c.ifr_name,interface,IFNAMSIZ-1);	if((ioctl(fd,SIOCGIFHWADDR,&ifreq_c))<0){		perror("Error in mac \n");		exit(1);	}	struct ethhdr *eth = (struct ethhdr *)(packet); / Filling Source mac address of the specified interface*/	eth->h_source[0] = (unsigned char)(ifreq_c.ifr_hwaddr.sa_data[0]);	eth->h_source[1] = (unsigned char)(ifreq_c.ifr_hwaddr.sa_data[1]);	eth->h_source[2] = (unsigned char)(ifreq_c.ifr_hwaddr.sa_data[2]);	eth->h_source[3] = (unsigned char)(ifreq_c.ifr_hwaddr.sa_data[3]);	eth->h_source[4] = (unsigned char)(ifreq_c.ifr_hwaddr.sa_data[4]);	eth->h_source[5] = (unsigned char)(ifreq_c.ifr_hwaddr.sa_data[5]); /* filling destination mac address as Broadcast address 255.255.255.255.255.255 /	eth->h_dest[0] = (unsigned char)(255);	eth->h_dest[1] = (unsigned char)(255);	eth->h_dest[2] = (unsigned char)(255);	eth->h_dest[3] = (unsigned char)(255);	eth->h_dest[4] = (unsigned char)(255);	eth->h_dest[5] = (unsigned char)(255);/ Filling the protocol Type... ARP / 	unsigned short protocol_id = 2054; // Decimal value for 0X0806	eth->h_proto = htons(protocol_id); // 0X0806 for ARP	extract_ethernet_header((void)packet); /* end of ethernet header // filling ARP request packet /	fillARP(packet,&ifreq_c);/ Sending ARP Packet to the Physical Layer /	struct sockaddr_ll sadr_ll;	sadr_ll.sll_ifindex = ifreq_i.ifr_ifindex; // index of interface	sadr_ll.sll_halen = ETH_ALEN; // length of destination mac address	sadr_ll.sll_addr[0] = (unsigned char)(255);	sadr_ll.sll_addr[1] = (unsigned char)(255);	sadr_ll.sll_addr[2] = (unsigned char)(255);	sadr_ll.sll_addr[3] = (unsigned char)(255);	sadr_ll.sll_addr[4] = (unsigned char)(255);	sadr_ll.sll_addr[5] = (unsigned char)(255);	int send_len = sendto(fd,packet,64,0,(const struct sockaddr)&sadr_ll,sizeof(struct sockaddr_ll));	if(send_len <0){		perror("Sending Error ");		exit(1);	}	pthread_t timer,receiver,processor;	pthread_create(&processor,NULL,&packet_processor,NULL);	pthread_create(&receiver, NULL,&waitForResponse,(void*)&fd);	pthread_create(&timer,NULL,&timerFun,NULL);	pthread_join(timer,NULL);	pthread_cancel(receiver);	close(fd);	return 0;}